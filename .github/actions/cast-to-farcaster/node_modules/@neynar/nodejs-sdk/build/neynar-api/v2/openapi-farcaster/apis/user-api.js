"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Farcaster API V2
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserApi = exports.UserApiFactory = exports.UserApiFp = exports.UserApiAxiosParamCreator = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("../common");
// @ts-ignore
const base_1 = require("../base");
/**
 * UserApi - axios parameter creator
 * @export
 */
const UserApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Fetches active users based on Warpcast active algorithm, information is updated every 12 hours
         * @summary Fetch active users
         * @param {string} apiKey API key required for authentication.
         * @param {number} [limit]
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activeUsers: async (apiKey, limit, cursor, options = {}) => {
            // verify required parameter 'apiKey' is not null or undefined
            (0, common_1.assertParamExists)('activeUsers', 'apiKey', apiKey);
            const localVarPath = `/farcaster/user/active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes verification for an eth address for the user \\ (In order to delete verification `signer_uuid` must be approved)
         * @summary Removes verification for an eth address for the user
         * @param {string} apiKey API key required for authentication.
         * @param {RemoveVerificationReqBody} removeVerificationReqBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        farcasterUserVerificationDelete: async (apiKey, removeVerificationReqBody, options = {}) => {
            // verify required parameter 'apiKey' is not null or undefined
            (0, common_1.assertParamExists)('farcasterUserVerificationDelete', 'apiKey', apiKey);
            // verify required parameter 'removeVerificationReqBody' is not null or undefined
            (0, common_1.assertParamExists)('farcasterUserVerificationDelete', 'removeVerificationReqBody', removeVerificationReqBody);
            const localVarPath = `/farcaster/user/verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(removeVerificationReqBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds verification for an eth address for the user \\ (In order to add verification `signer_uuid` must be approved)
         * @summary Adds verification for an eth address for the user
         * @param {string} apiKey API key required for authentication.
         * @param {AddVerificationReqBody} addVerificationReqBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        farcasterUserVerificationPost: async (apiKey, addVerificationReqBody, options = {}) => {
            // verify required parameter 'apiKey' is not null or undefined
            (0, common_1.assertParamExists)('farcasterUserVerificationPost', 'apiKey', apiKey);
            // verify required parameter 'addVerificationReqBody' is not null or undefined
            (0, common_1.assertParamExists)('farcasterUserVerificationPost', 'addVerificationReqBody', addVerificationReqBody);
            const localVarPath = `/farcaster/user/verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(addVerificationReqBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Follow a user \\ (In order to follow a user `signer_uuid` must be approved)
         * @summary Follow a user
         * @param {string} apiKey API key required for authentication.
         * @param {FollowReqBody} followReqBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followUser: async (apiKey, followReqBody, options = {}) => {
            // verify required parameter 'apiKey' is not null or undefined
            (0, common_1.assertParamExists)('followUser', 'apiKey', apiKey);
            // verify required parameter 'followReqBody' is not null or undefined
            (0, common_1.assertParamExists)('followUser', 'followReqBody', followReqBody);
            const localVarPath = `/farcaster/user/follow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(followReqBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches fid to assign it new user
         * @summary Fetches fid to assign it new user
         * @param {string} apiKey API key required for authentication.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFreshFid: async (apiKey, options = {}) => {
            // verify required parameter 'apiKey' is not null or undefined
            (0, common_1.assertParamExists)('getFreshFid', 'apiKey', apiKey);
            const localVarPath = `/farcaster/user/fid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lookup a user by custody-address
         * @summary Lookup a user by custody-address
         * @param {string} apiKey API key required for authentication.
         * @param {string} custodyAddress Custody Address associated with mnemonic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupUserByCustodyAddress: async (apiKey, custodyAddress, options = {}) => {
            // verify required parameter 'apiKey' is not null or undefined
            (0, common_1.assertParamExists)('lookupUserByCustodyAddress', 'apiKey', apiKey);
            // verify required parameter 'custodyAddress' is not null or undefined
            (0, common_1.assertParamExists)('lookupUserByCustodyAddress', 'custodyAddress', custodyAddress);
            const localVarPath = `/farcaster/user/custody-address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (custodyAddress !== undefined) {
                localVarQueryParameter['custody_address'] = custodyAddress;
            }
            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches power users based on Warpcast power badges
         * @summary Fetch power users
         * @param {string} apiKey API key required for authentication.
         * @param {number} [limit] Number of power users to fetch, max 100
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        powerUsers: async (apiKey, limit, cursor, options = {}) => {
            // verify required parameter 'apiKey' is not null or undefined
            (0, common_1.assertParamExists)('powerUsers', 'apiKey', apiKey);
            const localVarPath = `/farcaster/user/power`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register account on farcaster.
         * @summary Register account on farcaster
         * @param {string} apiKey API key required for authentication.
         * @param {RegisterUserReqBody} registerUserReqBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser: async (apiKey, registerUserReqBody, options = {}) => {
            // verify required parameter 'apiKey' is not null or undefined
            (0, common_1.assertParamExists)('registerUser', 'apiKey', apiKey);
            // verify required parameter 'registerUserReqBody' is not null or undefined
            (0, common_1.assertParamExists)('registerUser', 'registerUserReqBody', registerUserReqBody);
            const localVarPath = `/farcaster/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(registerUserReqBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unfollow a user \\ (In order to unfollow a user `signer_uuid` must be approved)
         * @summary Unfollow a user
         * @param {string} apiKey API key required for authentication.
         * @param {FollowReqBody} followReqBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfollowUser: async (apiKey, followReqBody, options = {}) => {
            // verify required parameter 'apiKey' is not null or undefined
            (0, common_1.assertParamExists)('unfollowUser', 'apiKey', apiKey);
            // verify required parameter 'followReqBody' is not null or undefined
            (0, common_1.assertParamExists)('unfollowUser', 'followReqBody', followReqBody);
            const localVarPath = `/farcaster/user/follow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(followReqBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user profile \\ (In order to update user\'s profile `signer_uuid` must be approved)
         * @summary Update user profile
         * @param {string} apiKey API key required for authentication.
         * @param {UpdateUserReqBody} updateUserReqBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (apiKey, updateUserReqBody, options = {}) => {
            // verify required parameter 'apiKey' is not null or undefined
            (0, common_1.assertParamExists)('updateUser', 'apiKey', apiKey);
            // verify required parameter 'updateUserReqBody' is not null or undefined
            (0, common_1.assertParamExists)('updateUser', 'updateUserReqBody', updateUserReqBody);
            const localVarPath = `/farcaster/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateUserReqBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches information about multiple users based on FIDs
         * @summary Fetch users based on FIDs
         * @param {string} apiKey API key required for authentication.
         * @param {string} fids Comma separated list of FIDs, up to 100 at a time
         * @param {number} [viewerFid]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBulk: async (apiKey, fids, viewerFid, options = {}) => {
            // verify required parameter 'apiKey' is not null or undefined
            (0, common_1.assertParamExists)('userBulk', 'apiKey', apiKey);
            // verify required parameter 'fids' is not null or undefined
            (0, common_1.assertParamExists)('userBulk', 'fids', fids);
            const localVarPath = `/farcaster/user/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (fids !== undefined) {
                localVarQueryParameter['fids'] = fids;
            }
            if (viewerFid !== undefined) {
                localVarQueryParameter['viewer_fid'] = viewerFid;
            }
            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches all users based on multiple Ethereum or Solana addresses.  Each farcaster user has a custody Ethereum address and optionally verified Ethereum or Solana addresses. This endpoint returns all users that have any of the given addresses as their custody or verified Ethereum or Solana addresses.  A custody address can be associated with only 1 farcaster user at a time but a verified address can be associated with multiple users. You can pass in Ethereum and Solana addresses, comma separated, in the same request. The response will contain users associated with the given addresses.
         * @summary Fetches users based on Eth or Sol addresses
         * @param {string} apiKey API key required for authentication.
         * @param {string} addresses Comma separated list of Ethereum addresses, up to 350 at a time
         * @param {string} [addressTypes] Customize which address types the request should search for. This is a comma-separated string that can include the following values: \&#39;custody_address\&#39; and \&#39;verified_address\&#39;. By default api returns both. To select multiple types, use a comma-separated list of these values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBulkByAddress: async (apiKey, addresses, addressTypes, options = {}) => {
            // verify required parameter 'apiKey' is not null or undefined
            (0, common_1.assertParamExists)('userBulkByAddress', 'apiKey', apiKey);
            // verify required parameter 'addresses' is not null or undefined
            (0, common_1.assertParamExists)('userBulkByAddress', 'addresses', addresses);
            const localVarPath = `/farcaster/user/bulk-by-address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (addresses !== undefined) {
                localVarQueryParameter['addresses'] = addresses;
            }
            if (addressTypes !== undefined) {
                localVarQueryParameter['address_types'] = addressTypes;
            }
            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for Usernames
         * @summary Search for Usernames
         * @param {string} apiKey API key required for authentication.
         * @param {string} q
         * @param {number} [viewerFid]
         * @param {number} [limit]
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSearch: async (apiKey, q, viewerFid, limit, cursor, options = {}) => {
            // verify required parameter 'apiKey' is not null or undefined
            (0, common_1.assertParamExists)('userSearch', 'apiKey', apiKey);
            // verify required parameter 'q' is not null or undefined
            (0, common_1.assertParamExists)('userSearch', 'q', q);
            const localVarPath = `/farcaster/user/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }
            if (viewerFid !== undefined) {
                localVarQueryParameter['viewer_fid'] = viewerFid;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.UserApiAxiosParamCreator = UserApiAxiosParamCreator;
/**
 * UserApi - functional programming interface
 * @export
 */
const UserApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.UserApiAxiosParamCreator)(configuration);
    return {
        /**
         * Fetches active users based on Warpcast active algorithm, information is updated every 12 hours
         * @summary Fetch active users
         * @param {string} apiKey API key required for authentication.
         * @param {number} [limit]
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activeUsers(apiKey, limit, cursor, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activeUsers(apiKey, limit, cursor, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Removes verification for an eth address for the user \\ (In order to delete verification `signer_uuid` must be approved)
         * @summary Removes verification for an eth address for the user
         * @param {string} apiKey API key required for authentication.
         * @param {RemoveVerificationReqBody} removeVerificationReqBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async farcasterUserVerificationDelete(apiKey, removeVerificationReqBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.farcasterUserVerificationDelete(apiKey, removeVerificationReqBody, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Adds verification for an eth address for the user \\ (In order to add verification `signer_uuid` must be approved)
         * @summary Adds verification for an eth address for the user
         * @param {string} apiKey API key required for authentication.
         * @param {AddVerificationReqBody} addVerificationReqBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async farcasterUserVerificationPost(apiKey, addVerificationReqBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.farcasterUserVerificationPost(apiKey, addVerificationReqBody, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Follow a user \\ (In order to follow a user `signer_uuid` must be approved)
         * @summary Follow a user
         * @param {string} apiKey API key required for authentication.
         * @param {FollowReqBody} followReqBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followUser(apiKey, followReqBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followUser(apiKey, followReqBody, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Fetches fid to assign it new user
         * @summary Fetches fid to assign it new user
         * @param {string} apiKey API key required for authentication.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFreshFid(apiKey, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFreshFid(apiKey, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Lookup a user by custody-address
         * @summary Lookup a user by custody-address
         * @param {string} apiKey API key required for authentication.
         * @param {string} custodyAddress Custody Address associated with mnemonic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupUserByCustodyAddress(apiKey, custodyAddress, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupUserByCustodyAddress(apiKey, custodyAddress, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Fetches power users based on Warpcast power badges
         * @summary Fetch power users
         * @param {string} apiKey API key required for authentication.
         * @param {number} [limit] Number of power users to fetch, max 100
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async powerUsers(apiKey, limit, cursor, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.powerUsers(apiKey, limit, cursor, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Register account on farcaster.
         * @summary Register account on farcaster
         * @param {string} apiKey API key required for authentication.
         * @param {RegisterUserReqBody} registerUserReqBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerUser(apiKey, registerUserReqBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerUser(apiKey, registerUserReqBody, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Unfollow a user \\ (In order to unfollow a user `signer_uuid` must be approved)
         * @summary Unfollow a user
         * @param {string} apiKey API key required for authentication.
         * @param {FollowReqBody} followReqBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unfollowUser(apiKey, followReqBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unfollowUser(apiKey, followReqBody, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Update user profile \\ (In order to update user\'s profile `signer_uuid` must be approved)
         * @summary Update user profile
         * @param {string} apiKey API key required for authentication.
         * @param {UpdateUserReqBody} updateUserReqBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(apiKey, updateUserReqBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(apiKey, updateUserReqBody, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Fetches information about multiple users based on FIDs
         * @summary Fetch users based on FIDs
         * @param {string} apiKey API key required for authentication.
         * @param {string} fids Comma separated list of FIDs, up to 100 at a time
         * @param {number} [viewerFid]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userBulk(apiKey, fids, viewerFid, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userBulk(apiKey, fids, viewerFid, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Fetches all users based on multiple Ethereum or Solana addresses.  Each farcaster user has a custody Ethereum address and optionally verified Ethereum or Solana addresses. This endpoint returns all users that have any of the given addresses as their custody or verified Ethereum or Solana addresses.  A custody address can be associated with only 1 farcaster user at a time but a verified address can be associated with multiple users. You can pass in Ethereum and Solana addresses, comma separated, in the same request. The response will contain users associated with the given addresses.
         * @summary Fetches users based on Eth or Sol addresses
         * @param {string} apiKey API key required for authentication.
         * @param {string} addresses Comma separated list of Ethereum addresses, up to 350 at a time
         * @param {string} [addressTypes] Customize which address types the request should search for. This is a comma-separated string that can include the following values: \&#39;custody_address\&#39; and \&#39;verified_address\&#39;. By default api returns both. To select multiple types, use a comma-separated list of these values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userBulkByAddress(apiKey, addresses, addressTypes, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userBulkByAddress(apiKey, addresses, addressTypes, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Search for Usernames
         * @summary Search for Usernames
         * @param {string} apiKey API key required for authentication.
         * @param {string} q
         * @param {number} [viewerFid]
         * @param {number} [limit]
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSearch(apiKey, q, viewerFid, limit, cursor, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSearch(apiKey, q, viewerFid, limit, cursor, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.UserApiFp = UserApiFp;
/**
 * UserApi - factory interface
 * @export
 */
const UserApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.UserApiFp)(configuration);
    return {
        /**
         * Fetches active users based on Warpcast active algorithm, information is updated every 12 hours
         * @summary Fetch active users
         * @param {string} apiKey API key required for authentication.
         * @param {number} [limit]
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activeUsers(apiKey, limit, cursor, options) {
            return localVarFp.activeUsers(apiKey, limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes verification for an eth address for the user \\ (In order to delete verification `signer_uuid` must be approved)
         * @summary Removes verification for an eth address for the user
         * @param {string} apiKey API key required for authentication.
         * @param {RemoveVerificationReqBody} removeVerificationReqBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        farcasterUserVerificationDelete(apiKey, removeVerificationReqBody, options) {
            return localVarFp.farcasterUserVerificationDelete(apiKey, removeVerificationReqBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds verification for an eth address for the user \\ (In order to add verification `signer_uuid` must be approved)
         * @summary Adds verification for an eth address for the user
         * @param {string} apiKey API key required for authentication.
         * @param {AddVerificationReqBody} addVerificationReqBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        farcasterUserVerificationPost(apiKey, addVerificationReqBody, options) {
            return localVarFp.farcasterUserVerificationPost(apiKey, addVerificationReqBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Follow a user \\ (In order to follow a user `signer_uuid` must be approved)
         * @summary Follow a user
         * @param {string} apiKey API key required for authentication.
         * @param {FollowReqBody} followReqBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followUser(apiKey, followReqBody, options) {
            return localVarFp.followUser(apiKey, followReqBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches fid to assign it new user
         * @summary Fetches fid to assign it new user
         * @param {string} apiKey API key required for authentication.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFreshFid(apiKey, options) {
            return localVarFp.getFreshFid(apiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Lookup a user by custody-address
         * @summary Lookup a user by custody-address
         * @param {string} apiKey API key required for authentication.
         * @param {string} custodyAddress Custody Address associated with mnemonic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupUserByCustodyAddress(apiKey, custodyAddress, options) {
            return localVarFp.lookupUserByCustodyAddress(apiKey, custodyAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches power users based on Warpcast power badges
         * @summary Fetch power users
         * @param {string} apiKey API key required for authentication.
         * @param {number} [limit] Number of power users to fetch, max 100
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        powerUsers(apiKey, limit, cursor, options) {
            return localVarFp.powerUsers(apiKey, limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Register account on farcaster.
         * @summary Register account on farcaster
         * @param {string} apiKey API key required for authentication.
         * @param {RegisterUserReqBody} registerUserReqBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(apiKey, registerUserReqBody, options) {
            return localVarFp.registerUser(apiKey, registerUserReqBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Unfollow a user \\ (In order to unfollow a user `signer_uuid` must be approved)
         * @summary Unfollow a user
         * @param {string} apiKey API key required for authentication.
         * @param {FollowReqBody} followReqBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfollowUser(apiKey, followReqBody, options) {
            return localVarFp.unfollowUser(apiKey, followReqBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user profile \\ (In order to update user\'s profile `signer_uuid` must be approved)
         * @summary Update user profile
         * @param {string} apiKey API key required for authentication.
         * @param {UpdateUserReqBody} updateUserReqBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(apiKey, updateUserReqBody, options) {
            return localVarFp.updateUser(apiKey, updateUserReqBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches information about multiple users based on FIDs
         * @summary Fetch users based on FIDs
         * @param {string} apiKey API key required for authentication.
         * @param {string} fids Comma separated list of FIDs, up to 100 at a time
         * @param {number} [viewerFid]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBulk(apiKey, fids, viewerFid, options) {
            return localVarFp.userBulk(apiKey, fids, viewerFid, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches all users based on multiple Ethereum or Solana addresses.  Each farcaster user has a custody Ethereum address and optionally verified Ethereum or Solana addresses. This endpoint returns all users that have any of the given addresses as their custody or verified Ethereum or Solana addresses.  A custody address can be associated with only 1 farcaster user at a time but a verified address can be associated with multiple users. You can pass in Ethereum and Solana addresses, comma separated, in the same request. The response will contain users associated with the given addresses.
         * @summary Fetches users based on Eth or Sol addresses
         * @param {string} apiKey API key required for authentication.
         * @param {string} addresses Comma separated list of Ethereum addresses, up to 350 at a time
         * @param {string} [addressTypes] Customize which address types the request should search for. This is a comma-separated string that can include the following values: \&#39;custody_address\&#39; and \&#39;verified_address\&#39;. By default api returns both. To select multiple types, use a comma-separated list of these values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBulkByAddress(apiKey, addresses, addressTypes, options) {
            return localVarFp.userBulkByAddress(apiKey, addresses, addressTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for Usernames
         * @summary Search for Usernames
         * @param {string} apiKey API key required for authentication.
         * @param {string} q
         * @param {number} [viewerFid]
         * @param {number} [limit]
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSearch(apiKey, q, viewerFid, limit, cursor, options) {
            return localVarFp.userSearch(apiKey, q, viewerFid, limit, cursor, options).then((request) => request(axios, basePath));
        },
    };
};
exports.UserApiFactory = UserApiFactory;
/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
class UserApi extends base_1.BaseAPI {
    /**
     * Fetches active users based on Warpcast active algorithm, information is updated every 12 hours
     * @summary Fetch active users
     * @param {string} apiKey API key required for authentication.
     * @param {number} [limit]
     * @param {string} [cursor] Pagination cursor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    activeUsers(apiKey, limit, cursor, options) {
        return (0, exports.UserApiFp)(this.configuration).activeUsers(apiKey, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Removes verification for an eth address for the user \\ (In order to delete verification `signer_uuid` must be approved)
     * @summary Removes verification for an eth address for the user
     * @param {string} apiKey API key required for authentication.
     * @param {RemoveVerificationReqBody} removeVerificationReqBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    farcasterUserVerificationDelete(apiKey, removeVerificationReqBody, options) {
        return (0, exports.UserApiFp)(this.configuration).farcasterUserVerificationDelete(apiKey, removeVerificationReqBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Adds verification for an eth address for the user \\ (In order to add verification `signer_uuid` must be approved)
     * @summary Adds verification for an eth address for the user
     * @param {string} apiKey API key required for authentication.
     * @param {AddVerificationReqBody} addVerificationReqBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    farcasterUserVerificationPost(apiKey, addVerificationReqBody, options) {
        return (0, exports.UserApiFp)(this.configuration).farcasterUserVerificationPost(apiKey, addVerificationReqBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Follow a user \\ (In order to follow a user `signer_uuid` must be approved)
     * @summary Follow a user
     * @param {string} apiKey API key required for authentication.
     * @param {FollowReqBody} followReqBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    followUser(apiKey, followReqBody, options) {
        return (0, exports.UserApiFp)(this.configuration).followUser(apiKey, followReqBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches fid to assign it new user
     * @summary Fetches fid to assign it new user
     * @param {string} apiKey API key required for authentication.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getFreshFid(apiKey, options) {
        return (0, exports.UserApiFp)(this.configuration).getFreshFid(apiKey, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lookup a user by custody-address
     * @summary Lookup a user by custody-address
     * @param {string} apiKey API key required for authentication.
     * @param {string} custodyAddress Custody Address associated with mnemonic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    lookupUserByCustodyAddress(apiKey, custodyAddress, options) {
        return (0, exports.UserApiFp)(this.configuration).lookupUserByCustodyAddress(apiKey, custodyAddress, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches power users based on Warpcast power badges
     * @summary Fetch power users
     * @param {string} apiKey API key required for authentication.
     * @param {number} [limit] Number of power users to fetch, max 100
     * @param {string} [cursor] Pagination cursor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    powerUsers(apiKey, limit, cursor, options) {
        return (0, exports.UserApiFp)(this.configuration).powerUsers(apiKey, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Register account on farcaster.
     * @summary Register account on farcaster
     * @param {string} apiKey API key required for authentication.
     * @param {RegisterUserReqBody} registerUserReqBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    registerUser(apiKey, registerUserReqBody, options) {
        return (0, exports.UserApiFp)(this.configuration).registerUser(apiKey, registerUserReqBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Unfollow a user \\ (In order to unfollow a user `signer_uuid` must be approved)
     * @summary Unfollow a user
     * @param {string} apiKey API key required for authentication.
     * @param {FollowReqBody} followReqBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    unfollowUser(apiKey, followReqBody, options) {
        return (0, exports.UserApiFp)(this.configuration).unfollowUser(apiKey, followReqBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update user profile \\ (In order to update user\'s profile `signer_uuid` must be approved)
     * @summary Update user profile
     * @param {string} apiKey API key required for authentication.
     * @param {UpdateUserReqBody} updateUserReqBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    updateUser(apiKey, updateUserReqBody, options) {
        return (0, exports.UserApiFp)(this.configuration).updateUser(apiKey, updateUserReqBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches information about multiple users based on FIDs
     * @summary Fetch users based on FIDs
     * @param {string} apiKey API key required for authentication.
     * @param {string} fids Comma separated list of FIDs, up to 100 at a time
     * @param {number} [viewerFid]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    userBulk(apiKey, fids, viewerFid, options) {
        return (0, exports.UserApiFp)(this.configuration).userBulk(apiKey, fids, viewerFid, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches all users based on multiple Ethereum or Solana addresses.  Each farcaster user has a custody Ethereum address and optionally verified Ethereum or Solana addresses. This endpoint returns all users that have any of the given addresses as their custody or verified Ethereum or Solana addresses.  A custody address can be associated with only 1 farcaster user at a time but a verified address can be associated with multiple users. You can pass in Ethereum and Solana addresses, comma separated, in the same request. The response will contain users associated with the given addresses.
     * @summary Fetches users based on Eth or Sol addresses
     * @param {string} apiKey API key required for authentication.
     * @param {string} addresses Comma separated list of Ethereum addresses, up to 350 at a time
     * @param {string} [addressTypes] Customize which address types the request should search for. This is a comma-separated string that can include the following values: \&#39;custody_address\&#39; and \&#39;verified_address\&#39;. By default api returns both. To select multiple types, use a comma-separated list of these values.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    userBulkByAddress(apiKey, addresses, addressTypes, options) {
        return (0, exports.UserApiFp)(this.configuration).userBulkByAddress(apiKey, addresses, addressTypes, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Search for Usernames
     * @summary Search for Usernames
     * @param {string} apiKey API key required for authentication.
     * @param {string} q
     * @param {number} [viewerFid]
     * @param {number} [limit]
     * @param {string} [cursor] Pagination cursor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    userSearch(apiKey, q, viewerFid, limit, cursor, options) {
        return (0, exports.UserApiFp)(this.configuration).userSearch(apiKey, q, viewerFid, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.UserApi = UserApi;
